 #!/usr/bin/env bash

if [[ "$(whoami)" != "oracle" ]]
then
    echo "This script is expected to be run as the Oracle user" 1>&2
    exit 1
fi 

HOSTNAME="${HOSTNAME}" 
INTERVAL={{ collectd_script_interval }}

while sleep "$INTERVAL"
do

    # We need to make sure this is in the path
    export PATH=$${PATH}:/usr/local/bin

    CRSCTL="$(dbhome +ASM)/bin/crsctl"

    for SID in {{ oracle_monitoring_list }}
    do

        if [[ -x "$${CRSCTL}" ]]
        then
            # Clustered Oracle
            ORACLE_SID="+ASM"
            ORAENV_ASK="NO"
            . oraenv > /dev/null

            # DB resources names are usually 'ora.$${DB}.db' but some have a suffix after $${DB}
            DB="$(crsctl status resource | grep -m1 -i ora\.${SID}.*\.db | cut -f2 -d=)"

            # Worth noting here that crsctl exits with code 0 even if you try and find details of a database that doesn't exist
            STATUS="$(crsctl status resource $${DB} -v | grep STATE_DETAILS | cut -f2 -d= | cut -f1 -d,)"

            case $${STATUS} in
                "Open")
                    VALUE=0
                    ;;
                "Open,Readonly")
                    VALUE=0
                    ;;
                "Mounted (Closed)")
                    VALUE=0
                    ;;
                *)
                    VALUE=1
                    ;;
            esac
        else
            # Not clustered so we use the sysdate query
            ORACLE_SID="${SID}"
            ORAENV_ASK="NO"
            . oraenv > /dev/null

            $${ORACLE_HOME}/bin/sqlplus / as sysdba <<-EOF > /dev/null
            set heading off
            WHENEVER SQLERROR EXIT SQL.SQLCODE
            select sysdate from dual;
EOF

            exit "$${?}"
        fi

    echo "PUTVAL \"$HOSTNAME/exec-oracle-health/db-${SID}\" interval=$INTERVAL N:$VALUE"
    done

done

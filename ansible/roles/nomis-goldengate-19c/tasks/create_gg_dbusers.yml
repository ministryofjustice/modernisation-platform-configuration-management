---
# Create GoldenGate administrator database user
# This user is created in the source and target databases with appropriate privileges
# Password retrieved from AWS Secrets Manager

# As auditdata and auditref streams both connect to the same audit database, they can use the same {{ oracle_goldengate_dbuser }} user and password for simplicity, so we only need to retrieve one password for both in this task and can reuse it when configuring the credential store

- name: Check for the database passwords in AWS Secrets Manager
  ansible.builtin.shell: |
    . ~/.bash_profile
    DB_PASSWORDS=$(aws secretsmanager get-secret-value \
      --secret-id "/oracle/database/{{ oracle_goldengate_local_db_sid }}/passwords" \
      --query 'SecretString' \
      --output text 2>/dev/null)

    if [ -z "${DB_PASSWORDS}" ]; then
      echo "ERROR: Failed to retrieve passwords from AWS Secrets Manager for {{ oracle_goldengate_local_db_sid }}"
      exit 1
    fi
  register: check_secrets_output
  become: yes
  become_user: "{{ oracle_goldengate_owner }}"
  args:
    executable: /bin/bash
  failed_when: check_secrets_output.rc != 0

- name: Check for GoldenGate database admin user in the secrets manager output
  ansible.builtin.shell: |
    . ~/.bash_profile
    SECRET_JSON=$(aws secretsmanager get-secret-value \
      --secret-id "/oracle/database/{{ oracle_goldengate_local_db_sid }}/passwords" \
      --query 'SecretString' \
      --output text 2>/dev/null)

    if [ -z "${SECRET_JSON}" ]; then
      echo "ERROR: Failed to retrieve passwords secret from AWS Secrets Manager for {{ oracle_goldengate_local_db_sid }}"
      exit 2
    fi

    if echo "${SECRET_JSON}" | jq -e --arg k "{{ oracle_goldengate_dbuser }}" '.[$k] // "" | length > 0' >/dev/null 2>&1; then
      echo "PRESENT"
      exit 0
    else
      echo "ABSENT"
      exit 1
    fi
  register: check_user_output
  become: yes
  become_user: "{{ oracle_goldengate_owner }}"
  args:
    executable: /bin/bash
  changed_when: false
  failed_when: check_user_output.rc not in [0, 1]

- name: Set fact whether GoldenGate admin user exists in Secrets Manager
  ansible.builtin.set_fact:
    gg_dbuser_exists_in_secrets_manager: "{{ check_user_output.rc == 0 }}"

- name: Skip GoldenGate admin user creation (already present in Secrets Manager)
  ansible.builtin.debug:
    msg: "{{ oracle_goldengate_dbuser }} already present in AWS Secrets Manager for {{ oracle_goldengate_local_db_sid }}, skipping database user creation tasks."
  when: gg_dbuser_exists_in_secrets_manager
  
- name: Create GoldenGate database admin user when local database is configured
  when:
    - oracle_goldengate_local_db_sid is defined
    - oracle_goldengate_local_db_sid in [oracle_goldengate_group.source.tns_alias, oracle_goldengate_group.auditdata.tns_alias, oracle_goldengate_group.mis.tns_alias]
    - not gg_dbuser_exists_in_secrets_manager
  block:
    - name: Generate random password for {{ oracle_goldengate_dbuser }} user
      ansible.builtin.set_fact:
        gg_dbuser_password: "{{ lookup('password', '/dev/null length=20 chars=ascii_letters,digits') }}"
        gg_oms_schema_password: "{{ lookup('password', '/dev/null length=20 chars=ascii_letters,digits') }}"
      no_log: true

    # CAPTURE priv is still needed for the source db user as the downstream capture process will connect remotely using this user, ÃŸbut we don't need to grant APPLY privileges on the source database as the replicat process won't be connecting to the source database
    - name: Set GoldenGate admin privileges based on database type 
      when: oracle_goldengate_local_db_sid in [oracle_goldengate_group.source.tns_alias]
      ansible.builtin.set_fact: 
        gg_privilege_type: 'CAPTURE'

    - name: Set GoldenGate admin privileges based on database type 
      when: oracle_goldengate_local_db_sid in [oracle_goldengate_group.auditdata.tns_alias, oracle_goldengate_group.auditref.tns_alias, oracle_goldengate_group.mis.tns_alias]
      ansible.builtin.set_fact: 
        gg_privilege_type: '*'

    # Create gg db user based on https://docs.oracle.com/en/middleware/goldengate/core/19.1/oracle-db/establishing-oracle-goldengate-credentials.html 
    - name: Create SQL script to create GoldenGate admin user
      ansible.builtin.copy:
        content: |
          -- Create GoldenGate Administrator User
          -- This user will be used for GoldenGate replication processes
          
          SET ECHO ON
          SET FEEDBACK ON
          
          WHENEVER SQLERROR EXIT SQL.SQLCODE
          
          -- Check if user exists
          DECLARE
            v_count NUMBER;
          BEGIN
            SELECT COUNT(*) INTO v_count FROM dba_users WHERE username = UPPER('{{ oracle_goldengate_dbuser }}');
            IF v_count > 0 THEN
              EXECUTE IMMEDIATE 'DROP USER {{ oracle_goldengate_dbuser }} CASCADE';
              DBMS_OUTPUT.PUT_LINE('Existing user {{ oracle_goldengate_dbuser }} dropped');
            END IF;
          END;
          /
          
          -- Create GoldenGate user
          PROMPT Creating GoldenGate user {{ oracle_goldengate_dbuser }}...
          CREATE USER {{ oracle_goldengate_dbuser }} IDENTIFIED BY "{{ gg_dbuser_password }}"
            DEFAULT TABLESPACE USERS
            TEMPORARY TABLESPACE TEMP
            QUOTA UNLIMITED ON USERS;
                   
          -- Grant additional GoldenGate-specific privileges
          GRANT CREATE SESSION TO {{ oracle_goldengate_dbuser }};
          GRANT CREATE VIEW to {{ oracle_goldengate_dbuser }};
          GRANT CONNECT to {{ oracle_goldengate_dbuser }};
          GRANT RESOURCE to {{ oracle_goldengate_dbuser }};
          GRANT ALTER SYSTEM to {{ oracle_goldengate_dbuser }} ;
          GRANT SELECT ANY DICTIONARY to {{ oracle_goldengate_dbuser }};
          GRANT SELECT ON v_$database to {{ oracle_goldengate_dbuser }};

          EXEC dbms_goldengate_auth.grant_admin_privilege (grantee => '{{ oracle_goldengate_dbuser }}', privilege_type => '{{ gg_privilege_type }}',  grant_select_privileges=> true, do_grants => TRUE); 

          -- Verify user creation
          PROMPT
          PROMPT Verifying user creation:
          SELECT username, account_status, default_tablespace, created 
          FROM dba_users 
          WHERE username = UPPER('{{ oracle_goldengate_dbuser }}');
          
          PROMPT
          PROMPT Verifying DBA privilege:
          SELECT grantee, granted_role 
          FROM dba_role_privs 
          WHERE grantee = UPPER('{{ oracle_goldengate_dbuser }}')
          AND granted_role = 'DBA';
          
          PROMPT
          PROMPT GoldenGate user {{ oracle_goldengate_dbuser }} created successfully!
          
          EXIT
        dest: "/tmp/create_gg_dbuser_{{ oracle_goldengate_local_db_sid }}.sql"
        owner: "{{ oracle_goldengate_owner }}"
        group: oinstall
        mode: "0600"
      no_log: true

    - name: Create GoldenGate database user
      ansible.builtin.shell: |
        . ~/.bash_profile
        export ORACLE_SID="{{ oracle_goldengate_local_db_sid }}"
        export ORACLE_HOME="{{ oracle_goldengate_group.source.oracle_home }}"
        export PATH="${ORACLE_HOME}/bin:${PATH}"

        LOCAL_DB_SID="{{ oracle_goldengate_local_db_sid }}"
        SOURCE_DB_SID="{{ oracle_goldengate_group.source.tns_alias }}"

        if [ "${LOCAL_DB_SID}" = "${SOURCE_DB_SID}" ]; then
          SYS_PASSWORD=$(aws secretsmanager get-secret-value \
            --secret-id "/oracle/database/{{ oracle_goldengate_local_db_sid }}/passwords" \
            --query 'SecretString' \
            --output text 2>/dev/null | jq -r '.sys' 2>/dev/null)

          if [ -z "${SYS_PASSWORD}" ]; then
            echo "ERROR: Failed to retrieve SYS password from AWS Secrets Manager for {{ oracle_goldengate_local_db_sid }}"
            exit 1
          fi

          SQL_CONNECT_STR="sys/${SYS_PASSWORD}@{{ oracle_goldengate_local_db_sid }} as sysdba"
        else
          SQL_CONNECT_STR="/ as sysdba"
        fi

        sqlplus -s "${SQL_CONNECT_STR}" @/tmp/create_gg_dbuser_{{ oracle_goldengate_local_db_sid }}.sql
      register: create_user_output
      become: yes
      become_user: "{{ oracle_goldengate_owner }}"
      args:
        executable: /bin/bash
      changed_when: "'created successfully' in create_user_output.stdout"
      failed_when: create_user_output.rc != 0

    - name: Display user creation results (sanitized)
      ansible.builtin.debug:
        msg: 
          - "Database: {{ oracle_goldengate_local_db_sid }}"
          - "GoldenGate user: {{ oracle_goldengate_dbuser }}"
          - "Status: {{ 'Created successfully' if create_user_output.changed else 'Already exists or error' }}"

    - name: Store {{ oracle_goldengate_dbuser }} password in AWS Secrets Manager
      ansible.builtin.shell: |
        . ~/.bash_profile

        # Retrieve current secret value
        CURRENT_SECRET=$(aws secretsmanager get-secret-value \
          --secret-id "/oracle/database/{{ oracle_goldengate_local_db_sid }}/passwords" \
          --query 'SecretString' \
          --output text 2>/dev/null)
        
        if [ -z "$CURRENT_SECRET" ]; then
          echo "ERROR: Cannot retrieve existing passwords secret for {{ oracle_goldengate_local_db_sid }}"
          exit 1
        fi

        # Check if {{ oracle_goldengate_dbuser }} password already exists
        if echo "$CURRENT_SECRET" | jq -e 'has("{{ oracle_goldengate_dbuser }}")' >/dev/null; then
          # If {{ oracle_goldengate_dbuser }} exists, check if the password needs updating
          CURRENT_PASSWORD=$(echo "$CURRENT_SECRET" | jq -r '.{{ oracle_goldengate_dbuser }}')
          if [ "$CURRENT_PASSWORD" != "{{ gg_dbuser_password }}" ]; then
            echo "Updating existing {{ oracle_goldengate_dbuser }} password in AWS Secrets Manager for {{ oracle_goldengate_local_db_sid }}"
            UPDATED_SECRET=$(echo "$CURRENT_SECRET" | jq --arg pwd "{{ gg_dbuser_password }}" '.{{ oracle_goldengate_dbuser }} = $pwd')
          else
            echo "{{ oracle_goldengate_dbuser }} password is already up-to-date in AWS Secrets Manager for {{ oracle_goldengate_local_db_sid }}"
            exit 0
          fi
        else
          # Add {{ oracle_goldengate_dbuser }} password to the existing secret
          echo "Adding {{ oracle_goldengate_dbuser }} password to AWS Secrets Manager for {{ oracle_goldengate_local_db_sid }}"
          UPDATED_SECRET=$(echo "$CURRENT_SECRET" | jq --arg pwd "{{ gg_dbuser_password }}" '. + { "{{ oracle_goldengate_dbuser }}": $pwd }')
        fi
        
        # Update the secret with the new value
        aws secretsmanager put-secret-value \
          --secret-id "/oracle/database/{{ oracle_goldengate_local_db_sid }}/passwords" \
          --secret-string "$UPDATED_SECRET"
      register: secret_store_output
      changed_when: "'ARN' in secret_store_output.stdout"
      failed_when: secret_store_output.rc != 0
      no_log: true

    - name: Display secret storage confirmation
      ansible.builtin.debug:
        msg: "GoldenGate {{ oracle_goldengate_dbuser }} password stored in AWS Secrets Manager at /oracle/database/{{ oracle_goldengate_local_db_sid }}/passwords ({{ oracle_goldengate_dbuser }} key)"

    - name: Clean up temporary SQL script
      ansible.builtin.file:
        path: "/tmp/create_gg_dbuser_{{ oracle_goldengate_local_db_sid }}.sql"
        state: absent

    - name: Create AUDITDATA schema if local database is the audit database
      when: oracle_goldengate_deploy_auditdata
      ansible.builtin.shell: |
        . ~/.bash_profile
        export ORACLE_SID={{ oracle_goldengate_group.auditdata.tns_alias }}
        export ORACLE_HOME={{ oracle_goldengate_group.source.oracle_home }}
        export PATH=${ORACLE_HOME}/bin:$PATH
        
        sqlplus -s / as sysdba <<EOF
        SET ECHO ON
        SET FEEDBACK ON
        
        WHENEVER SQLERROR EXIT SQL.SQLCODE

        -- Check if user exists
        DECLARE
          v_count NUMBER;
        BEGIN
          SELECT COUNT(*) INTO v_count FROM dba_users WHERE username = UPPER('{{ oracle_goldengate_group.auditdata.dummy_target_schema }}');
          IF v_count > 0 THEN
            EXECUTE IMMEDIATE 'DROP USER {{ oracle_goldengate_group.auditdata.dummy_target_schema }} CASCADE';
            DBMS_OUTPUT.PUT_LINE('Existing user {{ oracle_goldengate_group.auditdata.dummy_target_schema }} dropped');
          END IF;
        END;
        /
        
        -- For auditdata we need to create a dummy schema in the target database and create the table structures based on the source schema as we have to use MAP in the Replicat param file.
        -- User will be locked as we don't want anyone connecting to it, it's only needed for the Replicat MAP in the param file.
        CREATE USER {{ oracle_goldengate_group.auditdata.dummy_target_schema }} PROFILE DEFAULT 
        IDENTIFIED BY "{{ gg_oms_schema_password }}" 
        DEFAULT TABLESPACE USERS 
        TEMPORARY TABLESPACE TEMP 
        QUOTA UNLIMITED ON USERS 
        ACCOUNT LOCK;
        EXIT;
        EOF
      register: create_schema_output
      become: yes
      become_user: oracle
      changed_when: "'created' in create_schema_output.stdout"
      failed_when: create_schema_output.rc != 0 and 'already exists' not in create_schema_output.stderr
      no_log: true

    - name: Display schema creation results (sanitized)
      when: oracle_goldengate_deploy_auditdata
      ansible.builtin.debug:
        msg: 
          - "Database: {{ oracle_goldengate_local_db_sid }}"
          - "Schema: {{ oracle_goldengate_group.auditdata.dummy_target_schema }}"
          - "Status: {{ 'Created successfully' if create_schema_output.changed else 'Already exists or error' }}"

    - name: Create AUDITDATA tables if local database is the audit database
      when: oracle_goldengate_deploy_auditdata
      ansible.builtin.shell: |
        . ~/.bash_profile
        -- connect to source database as sysdba to generate DDL for the source tables, replacing the schema name with the target schema name in the output so that we can create the same table structures in the target database for the replicat MAP to work, and then execute the generated DDL in the target database to create the tables
        export ORACLE_SID={{ oracle_goldengate_group.source.tns_alias }}
        export ORACLE_HOME={{ oracle_goldengate_group.source.oracle_home }}
        export PATH=${ORACLE_HOME}/bin:$PATH

        # Retrieve SYS password from AWS Secrets Manager
        SYS_PASSWORD=$(aws secretsmanager get-secret-value \
          --secret-id "/oracle/database/${ORACLE_SID}/passwords" \
          --query 'SecretString' \
          --output text 2>/dev/null | jq -r '.sys' 2>/dev/null)
        
        if [ -z "$SYS_PASSWORD" ]; then
          echo "ERROR: Cannot retrieve existing passwords secret for ${ORACLE_SID}"
          exit 1
        fi
  
        sqlplus -s sys/"${SYS_PASSWORD}"@${ORACLE_SID} as sysdba <<EOF
        column c1 format a4000
        set wrap on
        SET LONG 2000000
        SET PAGESIZE 0
        SET LINESIZE 9999
        SET FEEDBACK OFF
        SET HEADING OFF
        SET ECHO OFF
        SET TRIMSPOOL ON
        SET TERMOUT OFF
        SET SERVEROUTPUT ON
        BEGIN
          DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform, 'SQLTERMINATOR', true);
          DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform, 'PRETTY', true);
          DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform, 'SIZE_BYTE_KEYWORD', false);
          DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform, 'SEGMENT_ATTRIBUTES', false);
          DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform, 'STORAGE', false);
        --   DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform, 'CONSTRAINTS', false);
          DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform, 'REF_CONSTRAINTS', false);
          DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform, 'TABLESPACE', false);
          DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform, 'PARTITIONING', false);
        END;
        /

        SELECT replace(DBMS_METADATA.get_ddl (o.object_type, o.object_name, o.owner),'{{ oracle_goldengate_group.source.schema_owner }}','{{ oracle_goldengate_group.auditdata.dummy_target_schema }}') c1
        FROM   dba_objects o
        WHERE  o.owner      = '{{ oracle_goldengate_group.source.schema_owner }}'
        AND    o.object_type in ('TABLE','CLUSTER')
        AND    EXISTS 
          (SELECT 1 FROM dual d 
            WHERE o.object_type = 'CLUSTER'
        	UNION 
        	SELECT 1 FROM dba_tables t 
            WHERE o.object_type = 'TABLE' 
            AND t.owner = o.owner 
            AND t.table_name = o.object_name 
            AND (t.TABLESPACE_NAME IS NOT null or (t.TABLESPACE_NAME IS null and t.partitioned = 'YES'))
            ) -- exclude external tables but not partitioned tables without a tablespace assigned
        order by decode(o.object_type, 'CLUSTER', 1, 'TABLE', 2), o.object_name

        spool /tmp/table_ddl.sql
        /

        spool off
        EXIT;
        EOF

        export ORACLE_SID={{ oracle_goldengate_local_db_sid }}
        export ORAENV_ASK=NO
        . oraenv > /dev/null 2>&1

        # run the same SQL script in the target database to create the tables there based on the source table structures
        sqlplus -s / as sysdba <<EOF
        SET ECHO ON
        SET FEEDBACK ON
        WHENEVER SQLERROR EXIT SQL.SQLCODE
        spool /tmp/create_auditdata_tables.log
        @/tmp/table_ddl.sql
        spool off
        EXIT;
        EOF
      register: create_tables_output
      become: yes
      become_user: "{{ oracle_goldengate_owner }}"
      args:
        executable: /bin/bash
      changed_when: "'TABLE' in create_tables_output.stdout"
      failed_when: create_tables_output.rc != 0
